<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animator Test</title>
    <script src="../../../dist/index.js"></script>
  </head>
  <body></body>
  <script>
    const { Utils, Canvas, Canvas2d, Color, Animator, Matrix } = Tela;
    const { vec2 } = Matrix;
    const { perf, testBuilder } = Utils;
    const test = testBuilder(() => {
      const width = 400;
      const height = 300;
      return Canvas.builder().width(width).height(height).build();
    });

    /**
     * Simple animation shader
     * */
    test("Test animation", (canvas) => {
      const T = 20;
      const { width, height } = canvas.canvas;
      Animator.builder()
        .initialState({ time: 0, oldT: new Date().getTime() })
        .nextState(({ time, oldT }) => {
          const newT = new Date().getTime();
          const dt = (newT - oldT) * 1e-3;
          canvas
            .map((c, x, y) => {
              let px = (y * time) / (width - 1);
              let py = ((height - 1 - x) * time) / (height - 1);
              return Color.ofRGBA(px * 255, py * 255, 0);
            })
            .paint();
          return { time: time + dt, oldT: newT };
        })
        .while(({ time }) => time <= T)
        .build()
        .play();
    });

    /**
     * Rotating grid shader
     **/
    test("Test shader toy", (canvas) => {
      const T = 20;
      const { width, height } = canvas;
      const step = (threshold) => (x) => x < threshold ? 0 : 1;
      const mod = (x) => (n) => ((x % n) + n) % n;
      Animator.builder()
        .initialState({ time: 0, oldT: new Date().getTime() })
        .nextState(({ time, oldT }) => {
          const newT = new Date().getTime();
          const dt = (newT - oldT) * 1e-3;
          canvas
            .map((c, x, y) => {
              let u = y / (width - 1);
              let v = (height - 1 - x) / (height - 1);
              const grid = 10;
              u *= grid;
              v *= grid;
              const t = 0.1 * time;
              u_t = Math.cos(t) * u + Math.sin(t) * v;
              v_t = -Math.sin(t) * u + Math.cos(t) * v;
              const color =
                (1 - step(0.95)(mod(u_t)(1))) * (1 - step(0.95)(mod(v_t)(1)));
              return Color.ofRGBA(255 * color, 255 * color, 255 * color);
            })
            .paint();
          return { time: time + dt, oldT: newT };
        })
        .while(({ time }) => time <= T)
        .build()
        .play();
    });

    testBuilder(() => {
      const width = 400;
      const height = 300;
      return Canvas2d.builder().width(width).height(height).build();
    })("Test wave physics", (canvas) => {
      const T = 100;
      const n = 50;
      const friction = 0.1;
      const gravity = -0.01;
      const amp = 0.5;
      const waveSpeed = 1;
      const freq = 0.3;
      const stopWaveTime = 3;
      let rope = [...new Array(100)].map((x, i) => (i === 0 ? 0.8 : 0));
      let ropeSpeed = [...new Array(100)].map((x, i) => 0);
      Animator.builder()
        .initialState({ time: 0, oldT: new Date().getTime() })
        .nextState(({ time, oldT }) => {
          const newT = new Date().getTime();
          const dt = (newT - oldT) * 1e-3;
          let xi = -1;
          const delta = 2 / n;
          canvas.fill();
          for (let i = 0; i < n - 1; i++) {
            const xii = xi + delta;
            canvas.drawLine([xi, rope[i]], [xii, rope[i + 1]], (i, j) =>
              Color.ofRGBA(0, 0, 0)
            );
            xi = xii;
          }
          canvas.paint();
          // update speed
          for (let i = 1; i < n - 1; i++) {
            const laplacian =
              (-2 * rope[i] + rope[i + 1] + rope[i - 1]) / delta;
            ropeSpeed[i] =
              ropeSpeed[i] +
              dt * (waveSpeed * laplacian + gravity - friction * ropeSpeed[i]);
          }
          // update position
          // update boundary
          rope[0] =
            time < stopWaveTime ? amp * Math.sin(2 * Math.PI * freq * time) : 0;
          rope[n - 1] = 0;
          for (let i = 1; i < n - 1; i++) {
            rope[i] = rope[i] + ropeSpeed[i] * dt;
          }
          return { time: time + dt, oldT: newT };
        })
        .while(({ time }) => time <= T)
        .build()
        .play();
    });
  </script>
</html>
