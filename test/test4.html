<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Test</title>
</head>

<body>
    <div>FPS: <span id="fps"></span></div>
    <!-- <div id="content" style="display: flex; width: 630px;height: 354px"> -->
    <div id="content">
    </div>
</body>
<script type="module">
    function toggleFullScreen(elem) {
        if (!document.fullscreenElement &&    // alternative standard method
            !document.mozFullScreenElement &&
            !document.webkitFullscreenElement &&
            !document.msFullscreenElement) {  // current working methods
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
        }
    }

    import { Animator, Canvas, Color } from "/dist/web/index.js";
    const width = 480;
    const height = 480;
    const canvas = Canvas.ofSize(width, height);
    canvas.DOM.setAttribute("style", "flex: 1");
    canvas.DOM.addEventListener("click", () => toggleFullScreen(canvas.DOM));
    document.getElementById("content").appendChild(canvas.DOM);
    let meanAverage = 0;

    const n = width;
    const d2xRec = n * n;
    const T = 100;
    const friction = 0.1;
    const amp = 100;
    const waveScalarSpeed = 20;
    const wave = [...new Array(height)].map((_, i) =>
        new Float64Array(width).map((_, j) => {
            const x = (j - width / 2) / width;
            const y = (i - height / 2) / height;
            return amp * Math.exp(-200 * (x * x + y * y));
        })
    );
    const waveSpeed = [...new Array(height)].map(
        () => new Float64Array(width)
    );
    const mod = (n, m) => ((n % m) + m) % m;
    Animator.builder()
        .initialState({ time: 0, oldT: new Date().getTime(), it: 1 })
        .nextState(({ time, oldT, it }) => {
            const newT = new Date().getTime();
            const dt = Math.min(0.015,(newT - oldT) * 1e-3);
            meanAverage = meanAverage + (dt - meanAverage) / it;
            document.getElementById("fps").innerText = String(1 / meanAverage);

            let maxWave = Number.MIN_VALUE;
            let minWave = Number.MAX_VALUE;
            let maxAbsSpeed = Number.MIN_VALUE;

            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    /**
                     * Sympletic integration
                     */
                    // compute acceleration
                    const laplacian =
                        wave[i][mod(j + 1, width)] +
                        wave[i][mod(j - 1, width)] +
                        wave[mod(i + 1, height)][j] +
                        wave[mod(i - 1, height)][j] -
                        4 * wave[i][j];
                    const acceleration = waveScalarSpeed * laplacian - friction * waveSpeed[i][j];

                    //update speed
                    waveSpeed[i][j] = waveSpeed[i][j] + dt * acceleration;

                    // update position
                    wave[i][j] = wave[i][j] + dt * waveSpeed[i][j];

                    // get max min values of wave
                    maxWave = maxWave <= wave[i][j] ? wave[i][j] : maxWave;
                    minWave = minWave > wave[i][j] ? wave[i][j] : minWave;
                    const absSpeed = Math.abs(waveSpeed[i][j]);
                    maxAbsSpeed = maxAbsSpeed <= absSpeed ? absSpeed : maxAbsSpeed;
                }
            }

            canvas.map((x, y) => {
                let xi = x;
                let yi = y;
                const redColor = (wave[yi][xi] - minWave) / (maxWave - minWave);
                const blueColor = 1 - (wave[yi][xi] - minWave) / (maxWave - minWave);
                const greenColor = Math.abs(waveSpeed[yi][xi]) / maxAbsSpeed;
                return Color.ofRGB(redColor, greenColor, blueColor);
            })
            return { time: time + dt, oldT: newT, it: it + 1 };
        })
        .while(({ time }) => time <= T)
        .build()
        .play();
</script>

</html>